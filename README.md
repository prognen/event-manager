## Название проекта

Организация мероприятий (EventManager).

## Описание идеи проекта

Приложение для планирования и организации мероприятий, которое помогает пользователям находить оптимальные программы сессий, размещения и активности на выбранной площадке. Приложение также рассчитывает общую стоимость участия в мероприятии, упрощая процесс организации. Это позволит пользователям быстро и удобно спланировать своё участие в конференциях, семинарах и других событиях.

## Описание предметной области

Сущности:
1. Пользователь
2. Мероприятие
3. Сессия
4. Площадка
5. Программа
6. Активности
7. Размещение

Роли:
1. Пользователь
2. Администратор

## Анализ аналогичных решений по минимум 3 критериям

|Название|Программа|Размещение|Активности| 
|--------|----------|-------------|--------------|
|Eventbrite|+|+|-| 
|Cvent|+|-|+|
|Мой проект|+|+|+|  

##5 Обоснование целесообразности и актуальности проекта 

Актуальность проекта заключается в упрощении планирования участия в мероприятиях, позволяя пользователям легко находить и бронировать программы сессий, размещение и активности в одном месте. С учётом растущего интереса к конференциям и деловым мероприятиям, создание удобного и функционального приложения становится необходимым. Это поможет пользователям сэкономить время и сделать процесс организации участия более комфортным.

##6 Описание акторов (ролей)

1. Пользователь: основной пользователь приложения, который планирует участие в мероприятиях.
2. Администратор -- обеспечивает актуальность и качество контента. Он отвечает за наполнение платформы информацией о размещении, активностях и программах мероприятий.

## Use-Case - диаграмма 

![uc](img/use_case.png)

## ER-диаграмма сущностей 

![er](img/er.png)

## Пользовательские сценарии

1. Зайти на основную страницу.
2. Авторизоваться, зайти на страницу своего профиля.
3. Зайти на страницу регистрации, зарегистрироваться или перейти на страницу авторизации.
4. Зайти на страницу авторизации, авторизироваться или перейти на страницу регистрации.
5. Посмотреть архив мероприятий.
6. Просмотреть официальные программы.
7. Записаться на сессию.
8. Посмотреть ближайшие запланированные активности в текущем мероприятии.
9. Поиск и фильтрация мероприятий.

## Формализация ключевых бизнес-процессов

![bpmn](img/bpmn.png)

## Технологический стек

* *Тип приложения* - Web MPA  
* *backend* - Python
* *frontend* - Python
* *database* - PostgreSQL  

## Верхнеуровневое разбиение на компоненты

![comp](img/comp.png)

## UML диаграммы классов для компонентов доступа к данным бизнес-логики

![uml](img/ppo.png)


## Запуск тестов

### Установка зависимостей

```bash
poetry install
```

### Запуск unit-тестов

```bash
# Стандартный запуск
poetry run pytest tests/unit -v

# Запуск в случайном порядке (используется по умолчанию через pytest-randomly)
poetry run pytest tests/unit -v --randomly-seed=random

# Запуск с фиксированным seed для воспроизводимости
poetry run pytest tests/unit -v --randomly-seed=42

# Запуск только "лондонских" тестов (с моками, работают без интернета)
poetry run pytest tests/unit -v -m unit
```

### Генерация отчёта Allure

```bash
# Запуск тестов с сохранением результатов для Allure
poetry run pytest tests/unit --alluredir=allure-results

# Открыть отчёт в браузере (требует установленного allure CLI)
allure serve allure-results
```

### Анализ процессов тестирования

По умолчанию pytest запускает **один процесс** на весь набор тестов. Все тест-файлы, классы и функции выполняются последовательно в этом одном процессе. Это конфигурируется через:
- `pyproject.toml` → `[tool.pytest.ini_options]`
- Плагин `pytest-xdist` (опция `-n auto`) позволяет запускать тесты параллельно в нескольких процессах

Текущая конфигурация: **1 процесс**, все 109 unit-тестов выполняются последовательно в одном запуске.

### Конфигурация pytest (`pyproject.toml`)

```toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
pythonpath = ["src", "tests"]
addopts = "--tb=short -p randomly"   # краткие трейсбеки + случайный порядок тестов
```

### Анализ вариантов тестирования

- **"Лондонский" вариант (с моками)** — все тесты в `tests/unit/` используют `unittest.mock.Mock` и `AsyncMock` для изоляции сервисов от репозиториев. Работают без БД и без сети.
- **Классический вариант (без моков)** — тесты в `tests/integration/` используют реальные репозитории и реальную тестовую БД PostgreSQL (создаётся в `conftest.py` в изолированной схеме).

Запуск только классических тестов (требует PostgreSQL):
```bash
poetry run pytest tests/integration -v -m integration
```